Что такое Rest API (http)? Soap? GraphQL? Websockets? RPC (gRPC, tRPC). Клиент - сервер. Вся теория

Но почему я HTTP-протокол объединила с архитектурным стилем (REST, SOAP) или же, с GraphQL с языком запросов?по сути это вообще
разное.
И на самом деле они отчасти будут правы.все это объединяет то, что это
клиент-серверная архитектура,это всё определяет способ общения клиента и сервера.
Про клиент-серверную архитектуру:
В такой архитектуре сервер выступает источником, всех вычислений, хранения данных,какой-то бизнес-логики, а клиенты с этим сервером
могут взаимодействовать. то есть есть железная машина на котором крутиться наше серверное приложение, которое взаимодействует с базой
данных,определяет протоколы взаимодействия,API определяет,и клиент в этой всей архитектуре с помощью каких-то определённых действий
может с
сервером общаться: может попросить какие-то данные у него, и сервер ему эти данные вернёт.
И всё это работает в формате "запрос-ответ", то есть клиент данные попросил - сервер эти данные вернул. И тут не только про данные,мы
также можем дать серверу выполнить какое-то действие, например, зарегистрировать нового пользователя или провести оплату или добавить
товар в корзину.И
соответственно сервер уже определяет, может он выполнить это действие или не может, и в зависимости от этого он будет возвращать
разный ответ,то есть сервер выступает как  единым источником вычислений.я в самом начале ошибочно думала, что клиент — это может быть
какой-то браузер. Но это и
мобильное приложение, и другой сервер, который обращается к нашему серверу, то есть любой и абсолютно любой контакт извне.даже если
мы сказали нашему умному дому включить чайник,то это уже то самое. То есть сама аббревиатура
"клиент-сервер" подразумевает, что сервер — это поставщик каких-то данных, услуг, логики, а клиент — это потребитель этих данных.
А для клиентов сервер — это такое единое, цельное,какое-то
монолитное приложение, источник данных. Но при этом сам сервер под капотом может быть большим,распределённым, состоящим из нескольких
микросервисов,но при этом клиента это особо не волнует и не должно.
Про то, на чём в принципе основан весь веб- это HTTP.
HTTP — это гипертекстовый транспортный протокол, который находится на самом верхнем уровне модели OSI,модели TCP/IP — это уровень
приложений.Именно с помощью HTTP общаются большинство приложений в интернете.
Первоначальная идея HTTP — это обмен гипертекстовыми документами,то есть нашими HTML-ками,но сейчас с помощью HTTP можно по сети
передавать практически любые данные: текстовые, файлы, HTML,XML, JSON — в общем, практически любой формат.
По структуре самого HTTP на пример запроса.если разобить HTTP-запрос на составные части и посмотрим на структуру,то первая строчка HTTP-запроса — это стартовая строка, и она из трёх частей:
Метод     URL      Версия HTTP
  !         !           !  
POST     /login      HTTP/1.0


Метод — это, грубо говоря, семантика запроса,то есть что мы хотим конкретно сделать,мы хотим создать какой-то ресурс, обновить его или получить. В данном случае POST говорит о том, что мы хотим какой-то ресурс создать или просто сделать что-то. 
URL — это то, куда мы отправляем запрос. В данном случае мы отправляем его на /login-то есть сервер понимает, какое именно действие мы хотим сделать.
Ну и далее указывается версия HTTP.


следующая часть структуры HTTP — это заголовки (headers).заголовки представляют достаточно важную информацию. В них есть часть заголовков обязательных и часть заголовков необязательных. так же можно составлять какие-то свои кастомные заголовки.
Host:example.com
Content-Type:application/x-www-form-urlencoded;charset=utf-8
Content-Length:26
В них указывается информация о хосте, с которого был отправлен запрос,
информация о браузере или о типе устройства, с которого отправляется запрос,
тип контента (text/html или какой-то другой тип),также могут отправляться различные авторизационные заголовки с токенами,также  ьлагодаря заголовкам обеспечивается безопасность взаимодействия различных источников сети (
CORS — заголовки,которые отвечают за безопасность общения источников, которые расположены на разных доменах).

Третья часть HTTP-запроса,любого HTTP запроса—это самотело сообщения,то есть в нём клиент отправляет серверу какие-то данные, которые ему необходимы, например в сообщении мы отправляем логин пользователя и пароль для того, чтобы сервер мог этого пользователя распознать, то есть клиент отправляет запрос, который выглядит таким образом:
{
    login=user
    password=qwerty
}
,и сервер должен вернуть ему ответ.
Ответ немного отличается от запроса
HTTP/1.1 200 OK
Content-Type:application/json
Connection:Closed
{
    message:'success login',
    user: {id:'1', username....}
}

стартовая строка выглядит немного по-другому, дело в том, что в ответе стартовая строка она называется "строка статуса",она  содержит версию HTTP,
такой статус-код, который определяет, успешно ли был выполнен запрос.
Также в ответе такие же headers заголовки, но они отличаються от тех, которые были в запросе,то есть есть заголовки запроса и есть заголовки ответа и  точно так же есть тело сообщения,в котором сервер возвращает клиенту какие-то данные.



HTTP методы-это та самая часть стартовой строки, 
Методов  большое количество, но если только основные, которыми чаще всего оперируют разработчики, методы:
GET-получение ресурса( запросить список товаров, запросить список пользователей,
запросить какую-то информацию расширенную по конкретному товару).
POST-передача данных(создание ресурса)(например, 
auth/login)
PUT-обновление ресурса(PUT и PATCH предназначены для обновления ресурса, но они тоже разные, PUT обновляет ресурс целиком,а
PATCH как правило обновляет только часть ресурса)
PATCH- обновление фрагменита ресурса частично
DELETE- удаление ресурса(удалить пользователя,товар)

строка статуса, которую возвращает сервер уже в виде ответа.
И здесь самой важной частью является статус-код, который сообщает о том,как
именно был обработан запрос,есть пять групп этих статус-кодов:
Информационные (1xx)—они всегда начинаются с единички (например, 100, 101, 102 и ......).
Успешные (2xx)—статус-коды,начинаются с двойки, обозначают, что запрос выполнился успешно.
Редиректы (3xx) начинаются с тройки,обычно означают какой-то редирект или перенаправление,например, мы успешно залогинились и нас перенаправляет на другую страницу.
Ошибки клиента (4xx)— начинаются с четвёрки,обозначают, что запрос был обработан с ошибкой
(например, клиент передал неправильные данные).404 (легендарный статус-код, который говорит о том, что какой-то ресурс не найден) видели все.тот самый легендарный 404 Not Found—когда мы не нашли ресурс,
400 Bad Request — статус-код чаще всего говорит, что запрос был некорректным (то есть опять же это всё про
семантику — ничего нам не мешает всегда ставить 400-й статус-код на все клиентские ошибки, но мы их подразделяем)
Ошибки сервера (5xx):Server Error(Ошибка сервера)—начинаются с пятёрки—это ошибки сервера (например, клиент передал данные все корректные, но на сервере написали неправильный код,там что-то сломалось,и сервер оответственно
возвращает 500-й статус-код).это еще называют "сервер пятисот".500 Internal Server Error—о том, что это внутренняя ошибка сервера.
ну и опять же,статус-коды—это про семантику,то есть ничего не мешает нам,на сервере выполнить какое-то действие с ошибкой, но вернуть 200-й статус-код. Но так как я понимаю обычно никто не делает.
То же самое и с методами—ничего не мешает сделать так,чтобы GET-запрос создавал какой-то ресурс, а не возвращал какие-то данные,но опять же так никто не делает.
201 Created-говорит об успехе,что ресурс был успешно создан,


REST API - application programming interface
архитектурный стиль, проверенный временем,который сообщает о
том,как наиболее эффективно общаться клиенту и серверу по HTTP,как с
программой стоит общаться.и это интерфейс именно программный.
Допустим, у нас есть программа, обратившись к которой мы можем
сделать следующие действия:
Получить актуальный курс валют,переконвертировать одну валюту в другую,получить прогноз погоды на неделю.Для этого сервер нам должен 
предоставить какой-то интерфейс,с помощью которого мы можем это сделать.мы должны отправить GET-запрос по определённому URL,в 
query-параметрах указать дату, на которую нам нужен прогноз, и город, для которого мы этот прогноз хотим получить. А сервер в 
качестве тела ответа вернётся в виде массива,
состоящего из объектов,в котором есть время,температура,будет ли дождь и  всю необходимую для нас информацию.
И мы видим,что отправив запрос с соответствующими параметрами, мы получим
соответствующий ответ. Это и есть API-то, как мы взаимодействуем с сервером. 


REST API: архитектурный стиль

это набор правил,который описывает,как использовать HTTP и строить свою API так, чтобы ей было удобно пользоваться,
чтобы она выдерживала нагрузки, легко масштабировалась и так далее. То есть чтобы мы извлекали все плюсы.

Первая концепция говорит о том, что модель взаимодействия с REST API-это клиент-сервер.API представлена в виде сервера,а 
потребителями (клиентами) могут быть как десктопные,браузерные,мобильные приложения, так и другие сервера, которые по какому-то 
контракту общаются с нашим сервером.
Следующая концепция-многоуровневость или многослойность системы. То есть по REST система может иметь n-ное количество слоёв, причём с 
точки зрения клиента это вообще никакой роли не играет.С точки зрения клиента эта вся
система она как бы цельная и единая, а внутри там может быть сколько угодно много слоёв с каким-нибудь
балансированием, распределением,с какой-нибудь микросервисной архитектурой.

Третья концепцияпро то, что сервер не должен обладать каким-либо состоянием (stateless(отсутствие состояния)).пример: клиент отправляет запрос,сервер возвращает ему какой-то ответ,и при этом никакого промежуточного состояния не запоминается (с точки зрения сервера).То есть при каждом следующем запросе клиент и сервер общаются как будто бы в первый раз.
Для того чтобы сервер идентифицировал клиента,какие данные вернуть, какую операцию произвести, клиент отправит всю необходимую информацию для того,чтобы сервер смог его обработать и выполнить.Это одна из самых важных концепций. 

Четвёртая концепция-это единообразный(унифицированный) интерфейс которым API обладает.у нас интернет-магазин. Над любыми товарами мы можем выполнять CRUD-операции (Create, Read, Update, Delete),то есть добавить товар,удалить товар,обновить информацию,получить список товаров(массив) и по ID  получаем информацию именно по конкретному товару
Как с такими операциями взаимодействовать? есть HTTP-методы POST, DELETE, PUT, PATCH и GET и каждый из этих методов обладает определённой семантикой
POST-создание,DELETE-удаление,PUT/PATCH-обновление,GET-получение
То есть для каждой CRUD-операции мы используем HTTP-метод,для каждой сущности у нас
есть определённый URL, по которому мы с ней взаимодействуем. В данном случае для товаров это URL----   /products
Если мы хотим получить информацию по конкретному товару, то у нас в конце добавляется ещё ID------  /products/{id}. Вот именно такая работа со всеми
endpoint'ами и есть тот самый единообразный,унифицированный интерфейс.
Сюда же можно ещё добавить формат взаимодействия (JSON, XML), заголовки, которые требуются для авторизации
пользователя (какой-нибудь токен).и 























